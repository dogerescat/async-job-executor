# Architecture

本ドキュメントでは、**Async Job Executor（仮称）** のアーキテクチャについて説明します。

本システムは、API を通じてユーザーからタスクを受け取り、  
それらを **非同期に Worker が実行** することで、  
構造化された手順データおよび Excel 形式の成果物を生成します。

---

## 目的（Goals）

本システムの設計における主な目的は以下の通りです。

- タスクを **登録** し、**実行状態を追跡** できるシンプルな API を提供する
- 長時間処理を同期 HTTP リクエストで実行せず、**非同期処理** とする
- **実行履歴およびログを保持** し、デバッグや再実行を容易にする
- API 契約を変更せずに、Worker の実装を **段階的に進化** させられるようにする
  （例：Java 実装から Go 実装への移行）

---

## システム構成概要

本システムは、以下のコンポーネントで構成されています。

- **API**

  - タスクの登録
  - タスク状態の取得
  - 再実行要求の受付

- **Worker**

  - キューからメッセージを取得し、タスクを実行
  - 実行結果・エラー・実行時間などを記録
  - 複数インスタンスでの水平スケールを想定

- **Database**

  - Task / TaskExecution / ログなどの永続化
  - マネージド PostgreSQL を想定

- **Queue**
  - API と Worker を疎結合にするための非同期キュー
  - 学習用途としては self-hosted、本番想定ではマネージドサービスを想定

---

## アーキテクチャ方針

### 非同期実行を前提とした設計

本システムでは、以下の理由から非同期実行を前提としています。

- 外部 API 呼び出しやファイル生成など、**処理時間が不定** なタスクを扱うため
- 同期 API ではタイムアウトやリトライ制御が難しいため
- 失敗や再試行を前提とした **堅牢な実行モデル** を構築するため

---

### Task と TaskExecution の分離

タスクの「目的」と、実行の「試行」を明確に分離しています。

- **Task**

  - ユーザーが登録した「やりたいこと」
  - 状態は `PENDING / RUNNING / COMPLETED / FAILED` のみを保持

- **TaskExecution**
  - 実際の実行試行（リトライを含む）
  - 実行回数、開始・終了時刻、エラー情報、入力・結果のスナップショットを保持

これにより、

- 状態爆発を防止し
- 再実行や監査、デバッグを容易にしています

---

### トランザクション設計

- トランザクションは **DB 内の状態確定のみに限定**
- 外部 API 呼び出しやファイル生成はトランザクション外で実行
- 状態遷移は **ガード条件付き UPDATE** により原子的に制御

詳細は `docs/transaction-policy.md` を参照してください。

---

## 将来拡張（Future Enhancements）

以下は、将来的な拡張として検討している項目です。

- 成果物のオブジェクトストレージ連携（S3 / GCS / Azure Blob 等）
- レートリミット・クォータ管理
- 遅延実行・スケジューリング
- ステップ単位での実行状態管理（生成だけでなく実行追跡）
- マルチテナント対応
- より強い一貫性保証（重複排除キー、Transactional Outbox など）

---
